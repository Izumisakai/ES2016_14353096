- ##实验截图

	<div align="center"><img src="https://github.com/Izumisakai/ES2016_14353096/blob/master/image/deadlock.png" width="50%",height="50%"></div>
	
- ##死锁产生的四个必要条件

	###1、互斥：至少有一个资源必须处于非共享模式，就是一次只有一个进程使用资源。
	
	###2、占有并等待：一个进程必须占有至少一个资源，并等待另一资源，而该资源为其他进程所占有
	
	###3、非抢占：资源不能被抢占，即资源只能在进程完成任务后自动释放。
	
	###4、循环等待：进程之间互相等待对方的资源，造成死循环。
	
- ##对死锁产生的解释

	###1、根据PPT的解释，用synchronized修饰的方法在同一个时间只能有一个线程在执行，就是保证互斥和非抢占的状态。
	
	###2、根据代码，执行deadlock构造函数之后会产生一个新的线程，这个线程会被插入到队列中，然后等到他的时候会运行run函数执行methodB方法，然后在等待完count时间后再执行methodA
	
	###3、那么死锁是怎么产生的呢，就是有这么一个时候，一个线程刚好从队列里面拿出来执行run函数跑methodB，然后另外一个线程count完然后执行methodA
	
	###4、因为你在跑methodB的时候是抢占资源B的，跑methodA的时候是抢占A的，所以这个时候互相想拿对方占有的资源，就满足了占有并等待和循环等待这两个条件，于是造成了死锁的产生。

